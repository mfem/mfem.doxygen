<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MFEM: mfem::ParMortarAssembler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams']
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="customization.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo-small.png"/></td>
  <td id="projectalign">
   <div id="projectname">MFEM<span id="projectnumber">&#160;v4.7.0</span>
   </div>
   <div id="projectbrief">Finite element discretization library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemfem.html">mfem</a></li><li class="navelem"><a class="el" href="classmfem_1_1ParMortarAssembler.html">ParMortarAssembler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmfem_1_1ParMortarAssembler-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mfem::ParMortarAssembler Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class implements the parallel variational transfer between finite element spaces. Variational transfer has been shown to have better approximation properties than standard interpolation. This facilities can be used for supporting applications which require the handling of non matching meshes. For instance: General multi-physics problems, fluid structure interaction, or even visualization of average quantities within subvolumes. This particular code is also used with LLNL for large scale multilevel Monte Carlo simulations. This algorithm allows to perform quadrature in the intersection of elements of two separate, unrelated, and arbitrarily distributed meshes. It generates quadrature rules in the intersection which allows us to integrate with to machine precision using the <a class="el" href="classmfem_1_1MortarIntegrator.html" title="Interface for mortar element assembly. The MortarIntegrator interface is used for performing Petrov-G...">mfem::MortarIntegrator</a> interface. See <a href="https://doi.org/10.1137/15M1008361">https://doi.org/10.1137/15M1008361</a> for and in-depth explanation. At this time curved elements are not supported. Convex non-affine elements are partially supported, however, high order (&gt;3) finite element discretizations or nonlinear geometric transformations might generate undesired oscillations. Discontinuous fields in general can only be mapped to order 0 destination fields. For such cases localized versions of the projection will have to be developed.  
 <a href="classmfem_1_1ParMortarAssembler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="pmortarassembler_8hpp_source.html">pmortarassembler.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a70bdde8ccf3565403e3275a064e1d31b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1ParMortarAssembler.html#a70bdde8ccf3565403e3275a064e1d31b">ParMortarAssembler</a> (const std::shared_ptr&lt; <a class="el" href="classmfem_1_1ParFiniteElementSpace.html">ParFiniteElementSpace</a> &gt; &amp;<a class="el" href="ex25_8cpp.html#aafef765e6aa140d0a04f5bedd532dc19">source</a>, const std::shared_ptr&lt; <a class="el" href="classmfem_1_1ParFiniteElementSpace.html">ParFiniteElementSpace</a> &gt; &amp;destination)</td></tr>
<tr class="memdesc:a70bdde8ccf3565403e3275a064e1d31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs the object with source and destination spaces  <br /></td></tr>
<tr class="separator:a70bdde8ccf3565403e3275a064e1d31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3ea836a30fc4987444802d68bd2e5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1ParMortarAssembler.html#acc3ea836a30fc4987444802d68bd2e5b">~ParMortarAssembler</a> ()</td></tr>
<tr class="separator:acc3ea836a30fc4987444802d68bd2e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624ddca19770df0f235d01ce52a6343e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1ParMortarAssembler.html#a624ddca19770df0f235d01ce52a6343e">Assemble</a> (std::shared_ptr&lt; <a class="el" href="classmfem_1_1HypreParMatrix.html">HypreParMatrix</a> &gt; &amp;B)</td></tr>
<tr class="memdesc:a624ddca19770df0f235d01ce52a6343e"><td class="mdescLeft">&#160;</td><td class="mdescRight">assembles the coupling matrix B. B : source -&gt; destination If u is a coefficient associated with source and v with destination Then v = M^(-1) * B * u; where M is the mass matrix in destination. Works with <a class="el" href="classmfem_1_1L2__FECollection.html" title="Arbitrary order &quot;L2-conforming&quot; discontinuous finite elements.">L2_FECollection</a>, <a class="el" href="classmfem_1_1H1__FECollection.html" title="Arbitrary order H1-conforming (continuous) finite elements.">H1_FECollection</a> and DG_FECollection (experimental with <a class="el" href="classmfem_1_1RT__FECollection.html" title="Arbitrary order H(div)-conforming Raviart-Thomas finite elements.">RT_FECollection</a> and <a class="el" href="classmfem_1_1ND__FECollection.html" title="Arbitrary order H(curl)-conforming Nedelec finite elements.">ND_FECollection</a>).  <br /></td></tr>
<tr class="separator:a624ddca19770df0f235d01ce52a6343e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9105824ddd208bee2ac3c08fa4802d50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1ParMortarAssembler.html#a9105824ddd208bee2ac3c08fa4802d50">Transfer</a> (const <a class="el" href="classmfem_1_1ParGridFunction.html">ParGridFunction</a> &amp;src_fun, <a class="el" href="classmfem_1_1ParGridFunction.html">ParGridFunction</a> &amp;dest_fun)</td></tr>
<tr class="memdesc:a9105824ddd208bee2ac3c08fa4802d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">transfer a function from source to destination. if the transfer is to be performed multiple times use Assemble or Update/Apply instead  <br /></td></tr>
<tr class="separator:a9105824ddd208bee2ac3c08fa4802d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0009120003a6afc017e73f6d83bb94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1ParMortarAssembler.html#a0b0009120003a6afc017e73f6d83bb94">Apply</a> (const <a class="el" href="classmfem_1_1ParGridFunction.html">ParGridFunction</a> &amp;src_fun, <a class="el" href="classmfem_1_1ParGridFunction.html">ParGridFunction</a> &amp;dest_fun)</td></tr>
<tr class="memdesc:a0b0009120003a6afc017e73f6d83bb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">transfer a function from source to destination. It requires that the Update function is called before  <br /></td></tr>
<tr class="separator:a0b0009120003a6afc017e73f6d83bb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff39a4a39bc2586ba516416e4cce45f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1ParMortarAssembler.html#aff39a4a39bc2586ba516416e4cce45f5">Update</a> ()</td></tr>
<tr class="memdesc:aff39a4a39bc2586ba516416e4cce45f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">assembles the various components necessary for the transfer. To be called before calling the Apply function if the mesh geometry changed, after previous call. Works with <a class="el" href="classmfem_1_1L2__FECollection.html" title="Arbitrary order &quot;L2-conforming&quot; discontinuous finite elements.">L2_FECollection</a>, <a class="el" href="classmfem_1_1H1__FECollection.html" title="Arbitrary order H1-conforming (continuous) finite elements.">H1_FECollection</a> and DG_FECollection (experimental with <a class="el" href="classmfem_1_1RT__FECollection.html" title="Arbitrary order H(div)-conforming Raviart-Thomas finite elements.">RT_FECollection</a> and <a class="el" href="classmfem_1_1ND__FECollection.html" title="Arbitrary order H(curl)-conforming Nedelec finite elements.">ND_FECollection</a>).  <br /></td></tr>
<tr class="separator:aff39a4a39bc2586ba516416e4cce45f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4e561a5eeeb51c0f288d7a664251e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1ParMortarAssembler.html#ada4e561a5eeeb51c0f288d7a664251e3">AddMortarIntegrator</a> (const std::shared_ptr&lt; <a class="el" href="classmfem_1_1MortarIntegrator.html">MortarIntegrator</a> &gt; &amp;integrator)</td></tr>
<tr class="memdesc:ada4e561a5eeeb51c0f288d7a664251e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be called before Assemble or Transfer. It will assemble the operator in all intersections found.  <br /></td></tr>
<tr class="separator:ada4e561a5eeeb51c0f288d7a664251e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6823b7dfae24cc82db483be5336cc18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1ParMortarAssembler.html#ad6823b7dfae24cc82db483be5336cc18">SetVerbose</a> (const bool verbose)</td></tr>
<tr class="memdesc:ad6823b7dfae24cc82db483be5336cc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expose process details with verbose output.  <br /></td></tr>
<tr class="separator:ad6823b7dfae24cc82db483be5336cc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7af2e3eb24126ccfd2f38797de2092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1ParMortarAssembler.html#a7a7af2e3eb24126ccfd2f38797de2092">SetAssembleMassAndCouplingTogether</a> (const bool value)</td></tr>
<tr class="memdesc:a7a7af2e3eb24126ccfd2f38797de2092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control if the Mass matrix is computed together with the coupling operator every time.  <br /></td></tr>
<tr class="separator:a7a7af2e3eb24126ccfd2f38797de2092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2948bf1882a51a473415a9e8ae679440"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1ParMortarAssembler.html#a2948bf1882a51a473415a9e8ae679440">SetMaxSolverIterations</a> (const int max_solver_iterations)</td></tr>
<tr class="memdesc:a2948bf1882a51a473415a9e8ae679440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the maximum numbers of conjugate gradients steps for mass matrix inversion.  <br /></td></tr>
<tr class="separator:a2948bf1882a51a473415a9e8ae679440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d3f528d64c174a3712d9a89ad76e5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1ParMortarAssembler.html#a10d3f528d64c174a3712d9a89ad76e5b">SetSolver</a> (const std::shared_ptr&lt; <a class="el" href="classmfem_1_1IterativeSolver.html">IterativeSolver</a> &gt; &amp;solver)</td></tr>
<tr class="memdesc:a10d3f528d64c174a3712d9a89ad76e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the solver to be used for solving the mass-matrix linear system.  <br /></td></tr>
<tr class="separator:a10d3f528d64c174a3712d9a89ad76e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements the parallel variational transfer between finite element spaces. Variational transfer has been shown to have better approximation properties than standard interpolation. This facilities can be used for supporting applications which require the handling of non matching meshes. For instance: General multi-physics problems, fluid structure interaction, or even visualization of average quantities within subvolumes. This particular code is also used with LLNL for large scale multilevel Monte Carlo simulations. This algorithm allows to perform quadrature in the intersection of elements of two separate, unrelated, and arbitrarily distributed meshes. It generates quadrature rules in the intersection which allows us to integrate with to machine precision using the <a class="el" href="classmfem_1_1MortarIntegrator.html" title="Interface for mortar element assembly. The MortarIntegrator interface is used for performing Petrov-G...">mfem::MortarIntegrator</a> interface. See <a href="https://doi.org/10.1137/15M1008361">https://doi.org/10.1137/15M1008361</a> for and in-depth explanation. At this time curved elements are not supported. Convex non-affine elements are partially supported, however, high order (&gt;3) finite element discretizations or nonlinear geometric transformations might generate undesired oscillations. Discontinuous fields in general can only be mapped to order 0 destination fields. For such cases localized versions of the projection will have to be developed. </p>

<p class="definition">Definition at line <a class="el" href="pmortarassembler_8hpp_source.html#l00049">49</a> of file <a class="el" href="pmortarassembler_8hpp_source.html">pmortarassembler.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a70bdde8ccf3565403e3275a064e1d31b" name="a70bdde8ccf3565403e3275a064e1d31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bdde8ccf3565403e3275a064e1d31b">&#9670;&#160;</a></span>ParMortarAssembler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mfem::ParMortarAssembler::ParMortarAssembler </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmfem_1_1ParFiniteElementSpace.html">ParFiniteElementSpace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmfem_1_1ParFiniteElementSpace.html">ParFiniteElementSpace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs the object with source and destination spaces </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source space from where we want to transfer the discrete field </td></tr>
    <tr><td class="paramname">destination</td><td>the source space to where we want to transfer the discrete field </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pmortarassembler_8cpp_source.html#l01087">1087</a> of file <a class="el" href="pmortarassembler_8cpp_source.html">pmortarassembler.cpp</a>.</p>

</div>
</div>
<a id="acc3ea836a30fc4987444802d68bd2e5b" name="acc3ea836a30fc4987444802d68bd2e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3ea836a30fc4987444802d68bd2e5b">&#9670;&#160;</a></span>~ParMortarAssembler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mfem::ParMortarAssembler::~ParMortarAssembler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ada4e561a5eeeb51c0f288d7a664251e3" name="ada4e561a5eeeb51c0f288d7a664251e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4e561a5eeeb51c0f288d7a664251e3">&#9670;&#160;</a></span>AddMortarIntegrator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mfem::ParMortarAssembler::AddMortarIntegrator </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmfem_1_1MortarIntegrator.html">MortarIntegrator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>integrator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method must be called before Assemble or Transfer. It will assemble the operator in all intersections found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">integrator</td><td>the integrator object </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pmortarassembler_8cpp_source.html#l00111">111</a> of file <a class="el" href="pmortarassembler_8cpp_source.html">pmortarassembler.cpp</a>.</p>

</div>
</div>
<a id="a0b0009120003a6afc017e73f6d83bb94" name="a0b0009120003a6afc017e73f6d83bb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0009120003a6afc017e73f6d83bb94">&#9670;&#160;</a></span>Apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mfem::ParMortarAssembler::Apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1ParGridFunction.html">ParGridFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>src_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmfem_1_1ParGridFunction.html">ParGridFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>dest_fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>transfer a function from source to destination. It requires that the Update function is called before </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">src_fun</td><td>the function associated with the source finite element space </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest_fun</td><td>the function associated with the destination finite element space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the transfer was successful, fail otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pmortarassembler_8cpp_source.html#l01132">1132</a> of file <a class="el" href="pmortarassembler_8cpp_source.html">pmortarassembler.cpp</a>.</p>

</div>
</div>
<a id="a624ddca19770df0f235d01ce52a6343e" name="a624ddca19770df0f235d01ce52a6343e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624ddca19770df0f235d01ce52a6343e">&#9670;&#160;</a></span>Assemble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mfem::ParMortarAssembler::Assemble </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmfem_1_1HypreParMatrix.html">HypreParMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assembles the coupling matrix B. B : source -&gt; destination If u is a coefficient associated with source and v with destination Then v = M^(-1) * B * u; where M is the mass matrix in destination. Works with <a class="el" href="classmfem_1_1L2__FECollection.html" title="Arbitrary order &quot;L2-conforming&quot; discontinuous finite elements.">L2_FECollection</a>, <a class="el" href="classmfem_1_1H1__FECollection.html" title="Arbitrary order H1-conforming (continuous) finite elements.">H1_FECollection</a> and DG_FECollection (experimental with <a class="el" href="classmfem_1_1RT__FECollection.html" title="Arbitrary order H(div)-conforming Raviart-Thomas finite elements.">RT_FECollection</a> and <a class="el" href="classmfem_1_1ND__FECollection.html" title="Arbitrary order H(curl)-conforming Nedelec finite elements.">ND_FECollection</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td>the assembled coupling operator. B can be passed uninitialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there was an intersection and the operator has been assembled. False otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pmortarassembler_8cpp_source.html#l01097">1097</a> of file <a class="el" href="pmortarassembler_8cpp_source.html">pmortarassembler.cpp</a>.</p>

</div>
</div>
<a id="a7a7af2e3eb24126ccfd2f38797de2092" name="a7a7af2e3eb24126ccfd2f38797de2092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7af2e3eb24126ccfd2f38797de2092">&#9670;&#160;</a></span>SetAssembleMassAndCouplingTogether()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mfem::ParMortarAssembler::SetAssembleMassAndCouplingTogether </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control if the Mass matrix is computed together with the coupling operator every time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is set to true for computing the mass matrix operator with the coupling operator, false otherwise. The option is true by default, set to false if only the coupling operator is needed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pmortarassembler_8cpp_source.html#l00099">99</a> of file <a class="el" href="pmortarassembler_8cpp_source.html">pmortarassembler.cpp</a>.</p>

</div>
</div>
<a id="a2948bf1882a51a473415a9e8ae679440" name="a2948bf1882a51a473415a9e8ae679440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2948bf1882a51a473415a9e8ae679440">&#9670;&#160;</a></span>SetMaxSolverIterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mfem::ParMortarAssembler::SetMaxSolverIterations </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_solver_iterations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the maximum numbers of conjugate gradients steps for mass matrix inversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_solver_iterations</td><td>the maximum number of iterations </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pmortarassembler_8cpp_source.html#l00104">104</a> of file <a class="el" href="pmortarassembler_8cpp_source.html">pmortarassembler.cpp</a>.</p>

</div>
</div>
<a id="a10d3f528d64c174a3712d9a89ad76e5b" name="a10d3f528d64c174a3712d9a89ad76e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d3f528d64c174a3712d9a89ad76e5b">&#9670;&#160;</a></span>SetSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mfem::ParMortarAssembler::SetSolver </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmfem_1_1IterativeSolver.html">IterativeSolver</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the solver to be used for solving the mass-matrix linear system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solver</td><td>new strategy </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pmortarassembler_8cpp_source.html#l00094">94</a> of file <a class="el" href="pmortarassembler_8cpp_source.html">pmortarassembler.cpp</a>.</p>

</div>
</div>
<a id="ad6823b7dfae24cc82db483be5336cc18" name="ad6823b7dfae24cc82db483be5336cc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6823b7dfae24cc82db483be5336cc18">&#9670;&#160;</a></span>SetVerbose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mfem::ParMortarAssembler::SetVerbose </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expose process details with verbose output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>set to true for verbose output </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pmortarassembler_8cpp_source.html#l00117">117</a> of file <a class="el" href="pmortarassembler_8cpp_source.html">pmortarassembler.cpp</a>.</p>

</div>
</div>
<a id="a9105824ddd208bee2ac3c08fa4802d50" name="a9105824ddd208bee2ac3c08fa4802d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9105824ddd208bee2ac3c08fa4802d50">&#9670;&#160;</a></span>Transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mfem::ParMortarAssembler::Transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1ParGridFunction.html">ParGridFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>src_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmfem_1_1ParGridFunction.html">ParGridFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>dest_fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>transfer a function from source to destination. if the transfer is to be performed multiple times use Assemble or Update/Apply instead </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">src_fun</td><td>the function associated with the source finite element space </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest_fun</td><td>the function associated with the destination finite element space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there was an intersection and the output can be used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pmortarassembler_8cpp_source.html#l01125">1125</a> of file <a class="el" href="pmortarassembler_8cpp_source.html">pmortarassembler.cpp</a>.</p>

</div>
</div>
<a id="aff39a4a39bc2586ba516416e4cce45f5" name="aff39a4a39bc2586ba516416e4cce45f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff39a4a39bc2586ba516416e4cce45f5">&#9670;&#160;</a></span>Update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mfem::ParMortarAssembler::Update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assembles the various components necessary for the transfer. To be called before calling the Apply function if the mesh geometry changed, after previous call. Works with <a class="el" href="classmfem_1_1L2__FECollection.html" title="Arbitrary order &quot;L2-conforming&quot; discontinuous finite elements.">L2_FECollection</a>, <a class="el" href="classmfem_1_1H1__FECollection.html" title="Arbitrary order H1-conforming (continuous) finite elements.">H1_FECollection</a> and DG_FECollection (experimental with <a class="el" href="classmfem_1_1RT__FECollection.html" title="Arbitrary order H(div)-conforming Raviart-Thomas finite elements.">RT_FECollection</a> and <a class="el" href="classmfem_1_1ND__FECollection.html" title="Arbitrary order H(curl)-conforming Nedelec finite elements.">ND_FECollection</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>true if there was an intersection and the operator has been assembled. False otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pmortarassembler_8cpp_source.html#l01185">1185</a> of file <a class="el" href="pmortarassembler_8cpp_source.html">pmortarassembler.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>fem/moonolith/<a class="el" href="pmortarassembler_8hpp_source.html">pmortarassembler.hpp</a></li>
<li>fem/moonolith/<a class="el" href="pmortarassembler_8cpp_source.html">pmortarassembler.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
