<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MFEM: mfem::Memory&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams']
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="customization.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo-small.png"/></td>
  <td id="projectalign">
   <div id="projectname">MFEM<span id="projectnumber">&#160;v4.7.0</span>
   </div>
   <div id="projectbrief">Finite element discretization library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemfem.html">mfem</a></li><li class="navelem"><a class="el" href="classmfem_1_1Memory.html">Memory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmfem_1_1Memory-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mfem::Memory&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class used by MFEM to store pointers to host and/or device memory.  
 <a href="classmfem_1_1Memory.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7af6e87336d9ae575d795a92511fd43c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a7af6e87336d9ae575d795a92511fd43c">Memory</a> ()</td></tr>
<tr class="separator:a7af6e87336d9ae575d795a92511fd43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbee21dd0c326971e91d11fa4245bbf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#abbee21dd0c326971e91d11fa4245bbf3">Memory</a> (const <a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;orig)=default</td></tr>
<tr class="memdesc:abbee21dd0c326971e91d11fa4245bbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: default.  <br /></td></tr>
<tr class="separator:abbee21dd0c326971e91d11fa4245bbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebb668bdda5058efd727fba8182f9a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#aeebb668bdda5058efd727fba8182f9a6">Memory</a> (<a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;&amp;orig)</td></tr>
<tr class="separator:aeebb668bdda5058efd727fba8182f9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b30d979258a63a39ac1d02bbe8afd24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a4b30d979258a63a39ac1d02bbe8afd24">operator=</a> (const <a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;orig)=default</td></tr>
<tr class="memdesc:a4b30d979258a63a39ac1d02bbe8afd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assignment operator: default.  <br /></td></tr>
<tr class="separator:a4b30d979258a63a39ac1d02bbe8afd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92050195c2e5faf16b95b464ac2582f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#af92050195c2e5faf16b95b464ac2582f">operator=</a> (<a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;&amp;orig)</td></tr>
<tr class="separator:af92050195c2e5faf16b95b464ac2582f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c01fd9d1a0c4ab67a0ca0c98680412"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ae1c01fd9d1a0c4ab67a0ca0c98680412">Memory</a> (int size)</td></tr>
<tr class="memdesc:ae1c01fd9d1a0c4ab67a0ca0c98680412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate host memory for <em>size</em> entries.  <br /></td></tr>
<tr class="separator:ae1c01fd9d1a0c4ab67a0ca0c98680412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102f6d8ce2d661f85de4b0f128699515"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a102f6d8ce2d661f85de4b0f128699515">Memory</a> (int size, <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> mt)</td></tr>
<tr class="memdesc:a102f6d8ce2d661f85de4b0f128699515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for <em>size</em> entries with the given MemoryType <em>mt</em>.  <br /></td></tr>
<tr class="separator:a102f6d8ce2d661f85de4b0f128699515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19521f075ac8b8b9a675eed59d9dc5df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a19521f075ac8b8b9a675eed59d9dc5df">Memory</a> (int size, <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> <a class="el" href="classmfem_1_1Memory.html#a465ea2a53d95684f97d8554dc80d8c95">h_mt</a>, <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> d_mt)</td></tr>
<tr class="memdesc:a19521f075ac8b8b9a675eed59d9dc5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for <em>size</em> entries with the given host MemoryType <em>h_mt</em> and device MemoryType <em>d_mt</em>.  <br /></td></tr>
<tr class="separator:a19521f075ac8b8b9a675eed59d9dc5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa79572a7c2f7a6c9fb4aeb84ad4661"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#affa79572a7c2f7a6c9fb4aeb84ad4661">Memory</a> (T *ptr, int size, bool own)</td></tr>
<tr class="memdesc:affa79572a7c2f7a6c9fb4aeb84ad4661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an externally allocated host pointer, <em>ptr</em> with the current host memory type returned by <a class="el" href="classmfem_1_1MemoryManager.html#a8242b5d31866354a39a9499aaceb1e10">MemoryManager::GetHostMemoryType()</a>.  <br /></td></tr>
<tr class="separator:affa79572a7c2f7a6c9fb4aeb84ad4661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b741efdece127b62d558f2d6cda057"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ae6b741efdece127b62d558f2d6cda057">Memory</a> (T *ptr, int size, <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> mt, bool own)</td></tr>
<tr class="memdesc:ae6b741efdece127b62d558f2d6cda057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an externally allocated pointer, <em>ptr</em>, of the given MemoryType.  <br /></td></tr>
<tr class="separator:ae6b741efdece127b62d558f2d6cda057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f74a8f481da9350110e69403339d44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a12f74a8f481da9350110e69403339d44">Memory</a> (const <a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;base, int offset, int size)</td></tr>
<tr class="memdesc:a12f74a8f481da9350110e69403339d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias constructor. Create a <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object that points inside the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object <em>base</em>.  <br /></td></tr>
<tr class="separator:a12f74a8f481da9350110e69403339d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb9e2bc14717bc0ffdd0a28588bc4e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a7cb9e2bc14717bc0ffdd0a28588bc4e3">~Memory</a> ()=default</td></tr>
<tr class="memdesc:a7cb9e2bc14717bc0ffdd0a28588bc4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: default.  <br /></td></tr>
<tr class="separator:a7cb9e2bc14717bc0ffdd0a28588bc4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6332d8de617e32e46a04f0af78bc7a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#aa6332d8de617e32e46a04f0af78bc7a8">OwnsHostPtr</a> () const</td></tr>
<tr class="memdesc:aa6332d8de617e32e46a04f0af78bc7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the host pointer is owned. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a>.  <br /></td></tr>
<tr class="separator:aa6332d8de617e32e46a04f0af78bc7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056cd85d58fc6ba570710765a69651eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a056cd85d58fc6ba570710765a69651eb">SetHostPtrOwner</a> (bool own) const</td></tr>
<tr class="memdesc:a056cd85d58fc6ba570710765a69651eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/clear the ownership flag for the host pointer. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a>.  <br /></td></tr>
<tr class="separator:a056cd85d58fc6ba570710765a69651eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a62868f97f98e658ba2b924faa7a782"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a0a62868f97f98e658ba2b924faa7a782">OwnsDevicePtr</a> () const</td></tr>
<tr class="memdesc:a0a62868f97f98e658ba2b924faa7a782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the device pointer is owned. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a>.  <br /></td></tr>
<tr class="separator:a0a62868f97f98e658ba2b924faa7a782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2362473c1d01b4dc65a89c0b2b014624"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a2362473c1d01b4dc65a89c0b2b014624">SetDevicePtrOwner</a> (bool own) const</td></tr>
<tr class="memdesc:a2362473c1d01b4dc65a89c0b2b014624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/clear the ownership flag for the device pointer. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a>.  <br /></td></tr>
<tr class="separator:a2362473c1d01b4dc65a89c0b2b014624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae951c1869b9e1bfdc04db54aa08591b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ae951c1869b9e1bfdc04db54aa08591b2">ClearOwnerFlags</a> () const</td></tr>
<tr class="memdesc:ae951c1869b9e1bfdc04db54aa08591b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the ownership flags for the host and device pointers, as well as any internal data allocated by the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object.  <br /></td></tr>
<tr class="separator:ae951c1869b9e1bfdc04db54aa08591b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d437d69150d64b5f15bf9f416ad3d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a91d437d69150d64b5f15bf9f416ad3d1">UseDevice</a> () const</td></tr>
<tr class="memdesc:a91d437d69150d64b5f15bf9f416ad3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the internal device flag.  <br /></td></tr>
<tr class="separator:a91d437d69150d64b5f15bf9f416ad3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca68c445b1ceef940243d2a156b872a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#aca68c445b1ceef940243d2a156b872a0">UseDevice</a> (bool use_dev) const</td></tr>
<tr class="memdesc:aca68c445b1ceef940243d2a156b872a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal device flag.  <br /></td></tr>
<tr class="separator:aca68c445b1ceef940243d2a156b872a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c60a5002e4a1972651b17f8e7231c99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a2c60a5002e4a1972651b17f8e7231c99">Capacity</a> () const</td></tr>
<tr class="memdesc:a2c60a5002e4a1972651b17f8e7231c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the allocated memory.  <br /></td></tr>
<tr class="separator:a2c60a5002e4a1972651b17f8e7231c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cb658936a2f7ef0033e7144b8f2ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ae0cb658936a2f7ef0033e7144b8f2ded">Reset</a> ()</td></tr>
<tr class="memdesc:ae0cb658936a2f7ef0033e7144b8f2ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the memory to be empty, ensuring that <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a> will be a no-op.  <br /></td></tr>
<tr class="separator:ae0cb658936a2f7ef0033e7144b8f2ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ac2ae58da2383aa01e8f812292fe0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a52ac2ae58da2383aa01e8f812292fe0a">Reset</a> (<a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> host_mt)</td></tr>
<tr class="memdesc:a52ac2ae58da2383aa01e8f812292fe0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the memory and set the host memory type.  <br /></td></tr>
<tr class="separator:a52ac2ae58da2383aa01e8f812292fe0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab88a8b55cb9d59a452b3e3e49e1a03a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#aab88a8b55cb9d59a452b3e3e49e1a03a">Empty</a> () const</td></tr>
<tr class="memdesc:aab88a8b55cb9d59a452b3e3e49e1a03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object is empty, see <a class="el" href="classmfem_1_1Memory.html#ae0cb658936a2f7ef0033e7144b8f2ded" title="Reset the memory to be empty, ensuring that Delete() will be a no-op.">Reset()</a>.  <br /></td></tr>
<tr class="separator:aab88a8b55cb9d59a452b3e3e49e1a03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8653bd0ddede4b32b498d56eab7a72f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#af8653bd0ddede4b32b498d56eab7a72f">New</a> (int size)</td></tr>
<tr class="memdesc:af8653bd0ddede4b32b498d56eab7a72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate host memory for <em>size</em> entries with the current host memory type returned by <a class="el" href="classmfem_1_1MemoryManager.html#a8242b5d31866354a39a9499aaceb1e10">MemoryManager::GetHostMemoryType()</a>.  <br /></td></tr>
<tr class="separator:af8653bd0ddede4b32b498d56eab7a72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bbd339334b49ff73abee09cf3f60ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a08bbd339334b49ff73abee09cf3f60ec">New</a> (int size, <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> mt)</td></tr>
<tr class="memdesc:a08bbd339334b49ff73abee09cf3f60ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for <em>size</em> entries with the given MemoryType.  <br /></td></tr>
<tr class="separator:a08bbd339334b49ff73abee09cf3f60ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae5b9bf408ab503de58fc6951148710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a3ae5b9bf408ab503de58fc6951148710">New</a> (int size, <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> <a class="el" href="classmfem_1_1Memory.html#a465ea2a53d95684f97d8554dc80d8c95">h_mt</a>, <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> d_mt)</td></tr>
<tr class="memdesc:a3ae5b9bf408ab503de58fc6951148710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for <em>size</em> entries with the given host MemoryType <em>h_mt</em> and device MemoryType <em>d_mt</em>.  <br /></td></tr>
<tr class="separator:a3ae5b9bf408ab503de58fc6951148710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33f0d9783e1129d8cf9d792b1aa360f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ae33f0d9783e1129d8cf9d792b1aa360f">Wrap</a> (T *ptr, int size, bool own)</td></tr>
<tr class="memdesc:ae33f0d9783e1129d8cf9d792b1aa360f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an externally allocated host pointer, <em>ptr</em> with the current host memory type returned by <a class="el" href="classmfem_1_1MemoryManager.html#a8242b5d31866354a39a9499aaceb1e10">MemoryManager::GetHostMemoryType()</a>.  <br /></td></tr>
<tr class="separator:ae33f0d9783e1129d8cf9d792b1aa360f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109d0d1215affe85a413f182f7c1e829"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a109d0d1215affe85a413f182f7c1e829">Wrap</a> (T *ptr, int size, <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> mt, bool own)</td></tr>
<tr class="memdesc:a109d0d1215affe85a413f182f7c1e829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an externally allocated pointer, <em>ptr</em>, of the given MemoryType.  <br /></td></tr>
<tr class="separator:a109d0d1215affe85a413f182f7c1e829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12c48b125333ecdcc72edd749d95a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#af12c48b125333ecdcc72edd749d95a5f">Wrap</a> (T *<a class="el" href="classmfem_1_1Memory.html#ab74d8712d2e64510cf8bfd256b656c16">h_ptr</a>, T *d_ptr, int size, <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> <a class="el" href="classmfem_1_1Memory.html#a465ea2a53d95684f97d8554dc80d8c95">h_mt</a>, bool own, bool valid_host=false, bool valid_device=true)</td></tr>
<tr class="separator:af12c48b125333ecdcc72edd749d95a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c80c40247a6a501cbc892063c19410"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a54c80c40247a6a501cbc892063c19410">MakeAlias</a> (const <a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;base, int offset, int size)</td></tr>
<tr class="memdesc:a54c80c40247a6a501cbc892063c19410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a memory object that points inside the memory object <em>base</em>.  <br /></td></tr>
<tr class="separator:a54c80c40247a6a501cbc892063c19410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207ff2d7f471881a398f85866d506951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a207ff2d7f471881a398f85866d506951">SetDeviceMemoryType</a> (<a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> d_mt)</td></tr>
<tr class="memdesc:a207ff2d7f471881a398f85866d506951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device MemoryType to be used by the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object.  <br /></td></tr>
<tr class="separator:a207ff2d7f471881a398f85866d506951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae561fa2849413502ad438425d430ab3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e">Delete</a> ()</td></tr>
<tr class="memdesc:ae561fa2849413502ad438425d430ab3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the owned pointers and reset the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object.  <br /></td></tr>
<tr class="separator:ae561fa2849413502ad438425d430ab3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3df5a574a44647abe81af9f997866c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ac3df5a574a44647abe81af9f997866c6">DeleteDevice</a> (bool copy_to_host=true)</td></tr>
<tr class="memdesc:ac3df5a574a44647abe81af9f997866c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the device pointer, if owned. If <em>copy_to_host</em> is true and the data is valid only on device, move it to host before deleting. Invalidates the device memory.  <br /></td></tr>
<tr class="separator:ac3df5a574a44647abe81af9f997866c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe83db8e05919fc63ddba24b823bf7b"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a2fe83db8e05919fc63ddba24b823bf7b">operator[]</a> (int idx)</td></tr>
<tr class="memdesc:a2fe83db8e05919fc63ddba24b823bf7b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmfem_1_1Array.html">Array</a> subscript operator for host memory.  <br /></td></tr>
<tr class="separator:a2fe83db8e05919fc63ddba24b823bf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece12a0a2d5c784f3a510d65e580d5d0"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#aece12a0a2d5c784f3a510d65e580d5d0">operator[]</a> (int idx) const</td></tr>
<tr class="memdesc:aece12a0a2d5c784f3a510d65e580d5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmfem_1_1Array.html">Array</a> subscript operator for host memory, const version.  <br /></td></tr>
<tr class="separator:aece12a0a2d5c784f3a510d65e580d5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe61dd5aa674a0726a086a6936ca5f99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#abe61dd5aa674a0726a086a6936ca5f99">operator T*</a> ()</td></tr>
<tr class="memdesc:abe61dd5aa674a0726a086a6936ca5f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the host memory as T* (implicit conversion).  <br /></td></tr>
<tr class="separator:abe61dd5aa674a0726a086a6936ca5f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b045973f3f7cebf6b0db63f17f0581e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a9b045973f3f7cebf6b0db63f17f0581e">operator const T *</a> () const</td></tr>
<tr class="memdesc:a9b045973f3f7cebf6b0db63f17f0581e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the host memory as const T* (implicit conversion).  <br /></td></tr>
<tr class="separator:a9b045973f3f7cebf6b0db63f17f0581e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfcca16e743e987a978f50796af216b"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:acbfcca16e743e987a978f50796af216b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#acbfcca16e743e987a978f50796af216b">operator U*</a> ()</td></tr>
<tr class="memdesc:acbfcca16e743e987a978f50796af216b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the host memory via explicit typecast.  <br /></td></tr>
<tr class="separator:acbfcca16e743e987a978f50796af216b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc509c7f05bd961e11fe98cebd3d701"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a9dc509c7f05bd961e11fe98cebd3d701"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a9dc509c7f05bd961e11fe98cebd3d701">operator const U *</a> () const</td></tr>
<tr class="memdesc:a9dc509c7f05bd961e11fe98cebd3d701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the host memory via explicit typecast, const version.  <br /></td></tr>
<tr class="separator:a9dc509c7f05bd961e11fe98cebd3d701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c5196970fcdb804fda39b12ce33a89"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a41c5196970fcdb804fda39b12ce33a89">ReadWrite</a> (<a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9ad">MemoryClass</a> mc, int size)</td></tr>
<tr class="memdesc:a41c5196970fcdb804fda39b12ce33a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get read-write access to the memory with the given MemoryClass.  <br /></td></tr>
<tr class="separator:a41c5196970fcdb804fda39b12ce33a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca11c25b3bab365636420fe0f95c740f"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#aca11c25b3bab365636420fe0f95c740f">Read</a> (<a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9ad">MemoryClass</a> mc, int size) const</td></tr>
<tr class="memdesc:aca11c25b3bab365636420fe0f95c740f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get read-only access to the memory with the given MemoryClass.  <br /></td></tr>
<tr class="separator:aca11c25b3bab365636420fe0f95c740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e426fd5bdf03fced16e7fc748e618b3"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a0e426fd5bdf03fced16e7fc748e618b3">Write</a> (<a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9ad">MemoryClass</a> mc, int size)</td></tr>
<tr class="memdesc:a0e426fd5bdf03fced16e7fc748e618b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get write-only access to the memory with the given MemoryClass.  <br /></td></tr>
<tr class="separator:a0e426fd5bdf03fced16e7fc748e618b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9792e65462ac4c305ffd32cc0f2123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#abb9792e65462ac4c305ffd32cc0f2123">Sync</a> (const <a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;other) const</td></tr>
<tr class="memdesc:abb9792e65462ac4c305ffd32cc0f2123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the host/device pointer validity flags from <em>other</em> to <em>*this</em>.  <br /></td></tr>
<tr class="separator:abb9792e65462ac4c305ffd32cc0f2123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973ee95b759c050ed6523a8e8257248e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a973ee95b759c050ed6523a8e8257248e">SyncAlias</a> (const <a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;base, int alias_size) const</td></tr>
<tr class="memdesc:a973ee95b759c050ed6523a8e8257248e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the alias <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> <em>*this</em> to match the memory location (all valid locations) of its base <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a>, <em>base</em>.  <br /></td></tr>
<tr class="separator:a973ee95b759c050ed6523a8e8257248e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5301afb7afa81ba494aee94f540558"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#aaa5301afb7afa81ba494aee94f540558">GetMemoryType</a> () const</td></tr>
<tr class="memdesc:aaa5301afb7afa81ba494aee94f540558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemoryType that is currently valid. If both the host and the device pointers are currently valid, then the device memory type is returned.  <br /></td></tr>
<tr class="separator:aaa5301afb7afa81ba494aee94f540558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1544186d45f8b52def0c76edfe8fecaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a1544186d45f8b52def0c76edfe8fecaa">GetHostMemoryType</a> () const</td></tr>
<tr class="memdesc:a1544186d45f8b52def0c76edfe8fecaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the host MemoryType of the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object.  <br /></td></tr>
<tr class="separator:a1544186d45f8b52def0c76edfe8fecaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40198dc79e6a148f13464c70b4683c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a40198dc79e6a148f13464c70b4683c07">GetDeviceMemoryType</a> () const</td></tr>
<tr class="memdesc:a40198dc79e6a148f13464c70b4683c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device MemoryType of the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object. If the device MemoryType is not set, return <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6a5b39c8b553c821e7cddc6da64b5bd2ee">MemoryType::DEFAULT</a>.  <br /></td></tr>
<tr class="separator:a40198dc79e6a148f13464c70b4683c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c2de394522406a1a0712343b1eb1f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a65c2de394522406a1a0712343b1eb1f8">HostIsValid</a> () const</td></tr>
<tr class="memdesc:a65c2de394522406a1a0712343b1eb1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if host pointer is valid.  <br /></td></tr>
<tr class="separator:a65c2de394522406a1a0712343b1eb1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e16c785a20e6d0ac026e3cb1817e34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a15e16c785a20e6d0ac026e3cb1817e34">DeviceIsValid</a> () const</td></tr>
<tr class="memdesc:a15e16c785a20e6d0ac026e3cb1817e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if device pointer is valid.  <br /></td></tr>
<tr class="separator:a15e16c785a20e6d0ac026e3cb1817e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35b55cdb9f0501fc80c17a0d771d2c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ad35b55cdb9f0501fc80c17a0d771d2c5">CopyFrom</a> (const <a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;src, int size)</td></tr>
<tr class="memdesc:ad35b55cdb9f0501fc80c17a0d771d2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <em>size</em> entries from <em>src</em> to <em>*this</em>.  <br /></td></tr>
<tr class="separator:ad35b55cdb9f0501fc80c17a0d771d2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9cc62d4a62456f698a39ddf9010319"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a2f9cc62d4a62456f698a39ddf9010319">CopyFromHost</a> (const T *src, int size)</td></tr>
<tr class="memdesc:a2f9cc62d4a62456f698a39ddf9010319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <em>size</em> entries from the host pointer <em>src</em> to <em>*this</em>.  <br /></td></tr>
<tr class="separator:a2f9cc62d4a62456f698a39ddf9010319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8938e297c15f2448abfeb63b2592da4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ae8938e297c15f2448abfeb63b2592da4">CopyTo</a> (<a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp;dest, int size) const</td></tr>
<tr class="memdesc:ae8938e297c15f2448abfeb63b2592da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <em>size</em> entries from <em>*this</em> to <em>dest</em>.  <br /></td></tr>
<tr class="separator:ae8938e297c15f2448abfeb63b2592da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935032383de7073af25dbd360dcb6b0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a935032383de7073af25dbd360dcb6b0f">CopyToHost</a> (T *dest, int size) const</td></tr>
<tr class="memdesc:a935032383de7073af25dbd360dcb6b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <em>size</em> entries from <em>*this</em> to the host pointer <em>dest</em>.  <br /></td></tr>
<tr class="separator:a935032383de7073af25dbd360dcb6b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d205fae2e89586bd2b805c624cb936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ac3d205fae2e89586bd2b805c624cb936">PrintFlags</a> () const</td></tr>
<tr class="memdesc:ac3d205fae2e89586bd2b805c624cb936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the internal flags.  <br /></td></tr>
<tr class="separator:ac3d205fae2e89586bd2b805c624cb936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcba0b7b9ca4d17a6342e172e7d63bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#acfcba0b7b9ca4d17a6342e172e7d63bb">CompareHostAndDevice</a> (int size) const</td></tr>
<tr class="memdesc:acfcba0b7b9ca4d17a6342e172e7d63bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If both the host and the device data are valid, compare their contents.  <br /></td></tr>
<tr class="separator:acfcba0b7b9ca4d17a6342e172e7d63bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a3d0f39428ffcae585ee8a5e07d6293c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a3d0f39428ffcae585ee8a5e07d6293c8">FlagMask</a> : unsigned { <br />
&#160;&#160;<a class="el" href="classmfem_1_1Memory.html#a3d0f39428ffcae585ee8a5e07d6293c8a71f2794e3bbd9eaa78d79f8674247d35">REGISTERED</a> = 1 &lt;&lt; 0
, <a class="el" href="classmfem_1_1Memory.html#a3d0f39428ffcae585ee8a5e07d6293c8ad93405b2f1dc47c7e9d024e89e167fd2">Registered</a> = 1 &lt;&lt; 0
, <a class="el" href="classmfem_1_1Memory.html#a3d0f39428ffcae585ee8a5e07d6293c8a82221cef35fabed8dfcbf4535e32f98e">OWNS_HOST</a> = 1 &lt;&lt; 1
, <a class="el" href="classmfem_1_1Memory.html#a3d0f39428ffcae585ee8a5e07d6293c8a068c473e63b3975e76bd7ffa97b9b5c3">OWNS_DEVICE</a> = 1 &lt;&lt; 2
, <br />
&#160;&#160;<a class="el" href="classmfem_1_1Memory.html#a3d0f39428ffcae585ee8a5e07d6293c8a1ba40eda130ac33b05d137ef20a228ce">OWNS_INTERNAL</a> = 1 &lt;&lt; 3
, <a class="el" href="classmfem_1_1Memory.html#a3d0f39428ffcae585ee8a5e07d6293c8a5929d77e0509d40bc61e2d8a0e80b435">VALID_HOST</a> = 1 &lt;&lt; 4
, <a class="el" href="classmfem_1_1Memory.html#a3d0f39428ffcae585ee8a5e07d6293c8a8dc25949c78815465778215543d1bfe9">VALID_DEVICE</a> = 1 &lt;&lt; 5
, <a class="el" href="classmfem_1_1Memory.html#a3d0f39428ffcae585ee8a5e07d6293c8a2e40ee01ee74c826ca6999aef88c179a">USE_DEVICE</a> = 1 &lt;&lt; 6
, <br />
&#160;&#160;<a class="el" href="classmfem_1_1Memory.html#a3d0f39428ffcae585ee8a5e07d6293c8ada467ac084790b0980b43e91c3af13b7">ALIAS</a> = 1 &lt;&lt; 7
<br />
 }</td></tr>
<tr class="separator:a3d0f39428ffcae585ee8a5e07d6293c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab74d8712d2e64510cf8bfd256b656c16"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ab74d8712d2e64510cf8bfd256b656c16">h_ptr</a></td></tr>
<tr class="memdesc:ab74d8712d2e64510cf8bfd256b656c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to host memory. Not owned.  <br /></td></tr>
<tr class="separator:ab74d8712d2e64510cf8bfd256b656c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d2f083d939a842e7a822882c69615c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#af3d2f083d939a842e7a822882c69615c">capacity</a></td></tr>
<tr class="memdesc:af3d2f083d939a842e7a822882c69615c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the allocated memory.  <br /></td></tr>
<tr class="separator:af3d2f083d939a842e7a822882c69615c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465ea2a53d95684f97d8554dc80d8c95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a465ea2a53d95684f97d8554dc80d8c95">h_mt</a></td></tr>
<tr class="memdesc:a465ea2a53d95684f97d8554dc80d8c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Host memory type.  <br /></td></tr>
<tr class="separator:a465ea2a53d95684f97d8554dc80d8c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac929fdb65bbfc48a96dc53479c680a6f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#ac929fdb65bbfc48a96dc53479c680a6f">flags</a></td></tr>
<tr class="memdesc:ac929fdb65bbfc48a96dc53479c680a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit flags defined from the <a class="el" href="classmfem_1_1Memory.html#a3d0f39428ffcae585ee8a5e07d6293c8">FlagMask</a> enum.  <br /></td></tr>
<tr class="separator:ac929fdb65bbfc48a96dc53479c680a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a714d9445184f29c663c1c02da59e9727"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#a714d9445184f29c663c1c02da59e9727">MemoryManager</a></td></tr>
<tr class="separator:a714d9445184f29c663c1c02da59e9727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80ea4d950a39cb98da7a6da3cf862bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmfem_1_1Memory.html#aa80ea4d950a39cb98da7a6da3cf862bc">MemoryPrintFlags</a> (unsigned <a class="el" href="classmfem_1_1Memory.html#ac929fdb65bbfc48a96dc53479c680a6f">flags</a>)</td></tr>
<tr class="memdesc:aa80ea4d950a39cb98da7a6da3cf862bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the state of a <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object based on its internal flags. Useful in a debugger. See also <a class="el" href="classmfem_1_1Memory.html#ac3d205fae2e89586bd2b805c624cb936" title="Print the internal flags.">Memory&lt;T&gt;::PrintFlags()</a>.  <br /></td></tr>
<tr class="separator:aa80ea4d950a39cb98da7a6da3cf862bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class mfem::Memory&lt; T &gt;</div><p>Class used by MFEM to store pointers to host and/or device memory. </p>
<p>The template class parameter, T, must be a plain-old-data (POD) type.</p>
<p>In many respects this class behaves like a pointer:</p><ul>
<li>When destroyed, a <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object does NOT automatically delete any allocated memory.</li>
<li>Only the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a> will deallocate a <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object.</li>
<li>Other methods that modify the object (e.g. <a class="el" href="classmfem_1_1Memory.html#af8653bd0ddede4b32b498d56eab7a72f" title="Allocate host memory for size entries with the current host memory type returned by MemoryManager::Ge...">New()</a>, <a class="el" href="classmfem_1_1Memory.html#ae33f0d9783e1129d8cf9d792b1aa360f" title="Wrap an externally allocated host pointer, ptr with the current host memory type returned by MemoryMa...">Wrap()</a>, etc) will simply overwrite the old contents. In other aspects this class differs from a pointer:</li>
<li>Pointer arithmetic is not supported, <a class="el" href="classmfem_1_1Memory.html#a54c80c40247a6a501cbc892063c19410" title="Create a memory object that points inside the memory object base.">MakeAlias()</a> should be used instead.</li>
<li>Const <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object does not allow modification of the content (unlike e.g. a const pointer).</li>
<li>Move constructor and assignment will transfer ownership flags, and <a class="el" href="classmfem_1_1Memory.html#ae0cb658936a2f7ef0033e7144b8f2ded" title="Reset the memory to be empty, ensuring that Delete() will be a no-op.">Reset()</a> the moved <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object.</li>
<li>Copy constructor and assignment copy flags. This may result in two <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> objects owning the data which is an invalid state. This invalid state MUST be resolved by users manually using <a class="el" href="classmfem_1_1Memory.html#a056cd85d58fc6ba570710765a69651eb" title="Set/clear the ownership flag for the host pointer. Ownership indicates whether the pointer will be de...">SetHostPtrOwner()</a>, <a class="el" href="classmfem_1_1Memory.html#a2362473c1d01b4dc65a89c0b2b014624" title="Set/clear the ownership flag for the device pointer. Ownership indicates whether the pointer will be ...">SetDevicePtrOwner()</a>, or <a class="el" href="classmfem_1_1Memory.html#ae951c1869b9e1bfdc04db54aa08591b2" title="Clear the ownership flags for the host and device pointers, as well as any internal data allocated by...">ClearOwnerFlags()</a>. It is also possible to call <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a> on only one of the two <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> objects, however this is discouraged because it bypasses the internal ownership flags.</li>
<li>When moving or copying (between host and device) alias <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> objects and/or their base <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> objects, the consistency of memory flags have to be manually taken care of using either <a class="el" href="classmfem_1_1Memory.html#abb9792e65462ac4c305ffd32cc0f2123" title="Copy the host/device pointer validity flags from other to *this.">Sync()</a> or <a class="el" href="classmfem_1_1Memory.html#a973ee95b759c050ed6523a8e8257248e" title="Update the alias Memory *this to match the memory location (all valid locations) of its base Memory,...">SyncAlias()</a>. Failure to do so will result in silent misuse of unsynchronized data.</li>
</ul>
<p>A <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object stores up to two different pointers: one host pointer (with MemoryType from <a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9adab9361011891280a44d85b967739cc6a5">MemoryClass::HOST</a>) and one device pointer (currently one of MemoryType: DEVICE, DEVICE_DEBUG, DEVICE_UMPIRE or MANAGED).</p>
<p>A <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object can hold (wrap) an externally allocated pointer with any given MemoryType.</p>
<p>Access to the content of the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object can be requested with any given MemoryClass through the methods <a class="el" href="classmfem_1_1Memory.html#a41c5196970fcdb804fda39b12ce33a89" title="Get read-write access to the memory with the given MemoryClass.">ReadWrite()</a>, <a class="el" href="classmfem_1_1Memory.html#aca11c25b3bab365636420fe0f95c740f" title="Get read-only access to the memory with the given MemoryClass.">Read()</a>, and <a class="el" href="classmfem_1_1Memory.html#a0e426fd5bdf03fced16e7fc748e618b3" title="Get write-only access to the memory with the given MemoryClass.">Write()</a>. Requesting such access may result in additional (internally handled) memory allocation and/or memory copy.</p><ul>
<li>When <a class="el" href="classmfem_1_1Memory.html#a41c5196970fcdb804fda39b12ce33a89" title="Get read-write access to the memory with the given MemoryClass.">ReadWrite()</a> is called, the returned pointer becomes the only valid pointer.</li>
<li>When <a class="el" href="classmfem_1_1Memory.html#aca11c25b3bab365636420fe0f95c740f" title="Get read-only access to the memory with the given MemoryClass.">Read()</a> is called, the returned pointer becomes valid, however the other pointer (host or device) may remain valid as well.</li>
<li>When <a class="el" href="classmfem_1_1Memory.html#a0e426fd5bdf03fced16e7fc748e618b3" title="Get write-only access to the memory with the given MemoryClass.">Write()</a> is called, the returned pointer becomes the only valid pointer, however, unlike <a class="el" href="classmfem_1_1Memory.html#a41c5196970fcdb804fda39b12ce33a89" title="Get read-write access to the memory with the given MemoryClass.">ReadWrite()</a>, no memory copy will be performed.</li>
</ul>
<p>The host memory (pointer from <a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9adab9361011891280a44d85b967739cc6a5">MemoryClass::HOST</a>) can be accessed through the inline methods: <code><a class="el" href="classmfem_1_1Memory.html#a2fe83db8e05919fc63ddba24b823bf7b" title="Array subscript operator for host memory.">operator[]()</a></code>, <code><a class="el" href="namespacemfem.html#a1dd8fb57059a48b1904c99f33ed3ad5f" title="Return a suitable MemoryClass from a pair of MemoryClasses.">operator*()</a></code>, the implicit conversion functions <code>operator T*()</code>, <code>operator const T*()</code>, and the explicit conversion template functions <code>operator U*()</code>, <code>operator const U*()</code> (with any suitable type U). In certain cases, using these methods may have undefined behavior, e.g. if the host pointer is not currently valid. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00167">167</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a3d0f39428ffcae585ee8a5e07d6293c8" name="a3d0f39428ffcae585ee8a5e07d6293c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0f39428ffcae585ee8a5e07d6293c8">&#9670;&#160;</a></span>FlagMask</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmfem_1_1Memory.html#a3d0f39428ffcae585ee8a5e07d6293c8">mfem::Memory::FlagMask</a> : unsigned</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3d0f39428ffcae585ee8a5e07d6293c8a71f2794e3bbd9eaa78d79f8674247d35" name="a3d0f39428ffcae585ee8a5e07d6293c8a71f2794e3bbd9eaa78d79f8674247d35"></a>REGISTERED&#160;</td><td class="fielddoc"><p>The host pointer is registered with the <a class="el" href="classmfem_1_1MemoryManager.html">MemoryManager</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d0f39428ffcae585ee8a5e07d6293c8ad93405b2f1dc47c7e9d024e89e167fd2" name="a3d0f39428ffcae585ee8a5e07d6293c8ad93405b2f1dc47c7e9d024e89e167fd2"></a>Registered&#160;</td><td class="fielddoc"><p>The host pointer is registered with the <a class="el" href="classmfem_1_1MemoryManager.html">MemoryManager</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d0f39428ffcae585ee8a5e07d6293c8a82221cef35fabed8dfcbf4535e32f98e" name="a3d0f39428ffcae585ee8a5e07d6293c8a82221cef35fabed8dfcbf4535e32f98e"></a>OWNS_HOST&#160;</td><td class="fielddoc"><p>The host pointer will be deleted by <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d0f39428ffcae585ee8a5e07d6293c8a068c473e63b3975e76bd7ffa97b9b5c3" name="a3d0f39428ffcae585ee8a5e07d6293c8a068c473e63b3975e76bd7ffa97b9b5c3"></a>OWNS_DEVICE&#160;</td><td class="fielddoc"><p>The device pointer will be deleted by <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d0f39428ffcae585ee8a5e07d6293c8a1ba40eda130ac33b05d137ef20a228ce" name="a3d0f39428ffcae585ee8a5e07d6293c8a1ba40eda130ac33b05d137ef20a228ce"></a>OWNS_INTERNAL&#160;</td><td class="fielddoc"><p>Ownership flag for internal <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d0f39428ffcae585ee8a5e07d6293c8a5929d77e0509d40bc61e2d8a0e80b435" name="a3d0f39428ffcae585ee8a5e07d6293c8a5929d77e0509d40bc61e2d8a0e80b435"></a>VALID_HOST&#160;</td><td class="fielddoc"><p>Host pointer is valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d0f39428ffcae585ee8a5e07d6293c8a8dc25949c78815465778215543d1bfe9" name="a3d0f39428ffcae585ee8a5e07d6293c8a8dc25949c78815465778215543d1bfe9"></a>VALID_DEVICE&#160;</td><td class="fielddoc"><p>Device pointer is valid </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d0f39428ffcae585ee8a5e07d6293c8a2e40ee01ee74c826ca6999aef88c179a" name="a3d0f39428ffcae585ee8a5e07d6293c8a2e40ee01ee74c826ca6999aef88c179a"></a>USE_DEVICE&#160;</td><td class="fielddoc"><p>Internal device flag, see e.g. <a class="el" href="classmfem_1_1Vector.html#ab321f069267cc57a8e44166b059e2fc8" title="Enable execution of Vector operations using the mfem::Device.">Vector::UseDevice()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d0f39428ffcae585ee8a5e07d6293c8ada467ac084790b0980b43e91c3af13b7" name="a3d0f39428ffcae585ee8a5e07d6293c8ada467ac084790b0980b43e91c3af13b7"></a>ALIAS&#160;</td><td class="fielddoc"><p>Pointer is an alias. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00173">173</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7af6e87336d9ae575d795a92511fd43c" name="a7af6e87336d9ae575d795a92511fd43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af6e87336d9ae575d795a92511fd43c">&#9670;&#160;</a></span>Memory() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor, sets the host pointer to nullptr and the metadata to meaningful default values. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00209">209</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="abbee21dd0c326971e91d11fa4245bbf3" name="abbee21dd0c326971e91d11fa4245bbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbee21dd0c326971e91d11fa4245bbf3">&#9670;&#160;</a></span>Memory() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Memory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: default. </p>

</div>
</div>
<a id="aeebb668bdda5058efd727fba8182f9a6" name="aeebb668bdda5058efd727fba8182f9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebb668bdda5058efd727fba8182f9a6">&#9670;&#160;</a></span>Memory() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Memory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Sets the pointers and associated ownership of validity flags of <em>*this</em> to those of <em>other</em>. Resets <em>other</em>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00216">216</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="ae1c01fd9d1a0c4ab67a0ca0c98680412" name="ae1c01fd9d1a0c4ab67a0ca0c98680412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c01fd9d1a0c4ab67a0ca0c98680412">&#9670;&#160;</a></span>Memory() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Memory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate host memory for <em>size</em> entries. </p>
<p>The allocation uses the current host memory type returned by <a class="el" href="classmfem_1_1MemoryManager.html#a8242b5d31866354a39a9499aaceb1e10">MemoryManager::GetHostMemoryType()</a>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00239">239</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a102f6d8ce2d661f85de4b0f128699515" name="a102f6d8ce2d661f85de4b0f128699515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102f6d8ce2d661f85de4b0f128699515">&#9670;&#160;</a></span>Memory() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Memory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>mt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for <em>size</em> entries with the given MemoryType <em>mt</em>. </p>
<p>The newly allocated memory is not initialized, however the given MemoryType is still set as valid. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00245">245</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a19521f075ac8b8b9a675eed59d9dc5df" name="a19521f075ac8b8b9a675eed59d9dc5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19521f075ac8b8b9a675eed59d9dc5df">&#9670;&#160;</a></span>Memory() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Memory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>h_mt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>d_mt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for <em>size</em> entries with the given host MemoryType <em>h_mt</em> and device MemoryType <em>d_mt</em>. </p>
<p>The newly allocated memory is not initialized. The host pointer is set as valid. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00251">251</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="affa79572a7c2f7a6c9fb4aeb84ad4661" name="affa79572a7c2f7a6c9fb4aeb84ad4661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa79572a7c2f7a6c9fb4aeb84ad4661">&#9670;&#160;</a></span>Memory() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Memory </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap an externally allocated host pointer, <em>ptr</em> with the current host memory type returned by <a class="el" href="classmfem_1_1MemoryManager.html#a8242b5d31866354a39a9499aaceb1e10">MemoryManager::GetHostMemoryType()</a>. </p>
<p>The parameter <em>own</em> determines whether <em>ptr</em> will be deleted when the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a> is called. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00257">257</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="ae6b741efdece127b62d558f2d6cda057" name="ae6b741efdece127b62d558f2d6cda057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b741efdece127b62d558f2d6cda057">&#9670;&#160;</a></span>Memory() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Memory </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>mt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap an externally allocated pointer, <em>ptr</em>, of the given MemoryType. </p>
<p>The new memory object will have the given MemoryType set as valid.</p>
<p>The given <em>ptr</em> must be allocated appropriately for the given MemoryType.</p>
<p>The parameter <em>own</em> determines whether <em>ptr</em> will be deleted when the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a> is called. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00267">267</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a12f74a8f481da9350110e69403339d44" name="a12f74a8f481da9350110e69403339d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f74a8f481da9350110e69403339d44">&#9670;&#160;</a></span>Memory() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Memory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias constructor. Create a <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object that points inside the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object <em>base</em>. </p>
<p>The new <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object uses the same <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6" title="Memory types supported by MFEM.">MemoryType(s)</a> as <em>base</em>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00273">273</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a7cb9e2bc14717bc0ffdd0a28588bc4e3" name="a7cb9e2bc14717bc0ffdd0a28588bc4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb9e2bc14717bc0ffdd0a28588bc4e3">&#9670;&#160;</a></span>~Memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::~<a class="el" href="classmfem_1_1Memory.html">Memory</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor: default. </p>
<dl class="section note"><dt>Note</dt><dd>The destructor will NOT delete the current memory. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2c60a5002e4a1972651b17f8e7231c99" name="a2c60a5002e4a1972651b17f8e7231c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c60a5002e4a1972651b17f8e7231c99">&#9670;&#160;</a></span>Capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the allocated memory. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00311">311</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="ae951c1869b9e1bfdc04db54aa08591b2" name="ae951c1869b9e1bfdc04db54aa08591b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae951c1869b9e1bfdc04db54aa08591b2">&#9670;&#160;</a></span>ClearOwnerFlags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::ClearOwnerFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the ownership flags for the host and device pointers, as well as any internal data allocated by the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00300">300</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="acfcba0b7b9ca4d17a6342e172e7d63bb" name="acfcba0b7b9ca4d17a6342e172e7d63bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcba0b7b9ca4d17a6342e172e7d63bb">&#9670;&#160;</a></span>CompareHostAndDevice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::CompareHostAndDevice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If both the host and the device data are valid, compare their contents. </p>
<p>This method can be useful for debugging. It is explicitly instantiated for Memory&lt;T&gt; with T = int and T = real_t. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01340">1340</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="ad35b55cdb9f0501fc80c17a0d771d2c5" name="ad35b55cdb9f0501fc80c17a0d771d2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35b55cdb9f0501fc80c17a0d771d2c5">&#9670;&#160;</a></span>CopyFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::CopyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy <em>size</em> entries from <em>src</em> to <em>*this</em>. </p>
<p>The given <em>size</em> should not exceed the <a class="el" href="classmfem_1_1Memory.html#a2c60a5002e4a1972651b17f8e7231c99" title="Return the size of the allocated memory.">Capacity()</a> of the source <em>src</em> and the destination, <em>*this</em>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01260">1260</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a2f9cc62d4a62456f698a39ddf9010319" name="a2f9cc62d4a62456f698a39ddf9010319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9cc62d4a62456f698a39ddf9010319">&#9670;&#160;</a></span>CopyFromHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::CopyFromHost </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy <em>size</em> entries from the host pointer <em>src</em> to <em>*this</em>. </p>
<p>The given <em>size</em> should not exceed the <a class="el" href="classmfem_1_1Memory.html#a2c60a5002e4a1972651b17f8e7231c99" title="Return the size of the allocated memory.">Capacity()</a> of <em>*this</em>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01281">1281</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="ae8938e297c15f2448abfeb63b2592da4" name="ae8938e297c15f2448abfeb63b2592da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8938e297c15f2448abfeb63b2592da4">&#9670;&#160;</a></span>CopyTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::CopyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy <em>size</em> entries from <em>*this</em> to <em>dest</em>. </p>
<p>The given <em>size</em> should not exceed the <a class="el" href="classmfem_1_1Memory.html#a2c60a5002e4a1972651b17f8e7231c99" title="Return the size of the allocated memory.">Capacity()</a> of <em>*this</em> and the destination, <em>dest</em>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01302">1302</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a935032383de7073af25dbd360dcb6b0f" name="a935032383de7073af25dbd360dcb6b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935032383de7073af25dbd360dcb6b0f">&#9670;&#160;</a></span>CopyToHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::CopyToHost </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy <em>size</em> entries from <em>*this</em> to the host pointer <em>dest</em>. </p>
<p>The given <em>size</em> should not exceed the <a class="el" href="classmfem_1_1Memory.html#a2c60a5002e4a1972651b17f8e7231c99" title="Return the size of the allocated memory.">Capacity()</a> of <em>*this</em>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01308">1308</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="ae561fa2849413502ad438425d430ab3e" name="ae561fa2849413502ad438425d430ab3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae561fa2849413502ad438425d430ab3e">&#9670;&#160;</a></span>Delete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the owned pointers and reset the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01092">1092</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="ac3df5a574a44647abe81af9f997866c6" name="ac3df5a574a44647abe81af9f997866c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3df5a574a44647abe81af9f997866c6">&#9670;&#160;</a></span>DeleteDevice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::DeleteDevice </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_to_host</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the device pointer, if owned. If <em>copy_to_host</em> is true and the data is valid only on device, move it to host before deleting. Invalidates the device memory. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01111">1111</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a15e16c785a20e6d0ac026e3cb1817e34" name="a15e16c785a20e6d0ac026e3cb1817e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e16c785a20e6d0ac026e3cb1817e34">&#9670;&#160;</a></span>DeviceIsValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::DeviceIsValid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if device pointer is valid. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01254">1254</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="aab88a8b55cb9d59a452b3e3e49e1a03a" name="aab88a8b55cb9d59a452b3e3e49e1a03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab88a8b55cb9d59a452b3e3e49e1a03a">&#9670;&#160;</a></span>Empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object is empty, see <a class="el" href="classmfem_1_1Memory.html#ae0cb658936a2f7ef0033e7144b8f2ded" title="Reset the memory to be empty, ensuring that Delete() will be a no-op.">Reset()</a>. </p>
<p>Default-constructed objects are uninitialized, so they are not guaranteed to be empty. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00326">326</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a40198dc79e6a148f13464c70b4683c07" name="a40198dc79e6a148f13464c70b4683c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40198dc79e6a148f13464c70b4683c07">&#9670;&#160;</a></span>GetDeviceMemoryType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::GetDeviceMemoryType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the device MemoryType of the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object. If the device MemoryType is not set, return <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6a5b39c8b553c821e7cddc6da64b5bd2ee">MemoryType::DEFAULT</a>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01241">1241</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a1544186d45f8b52def0c76edfe8fecaa" name="a1544186d45f8b52def0c76edfe8fecaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1544186d45f8b52def0c76edfe8fecaa">&#9670;&#160;</a></span>GetHostMemoryType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::GetHostMemoryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the host MemoryType of the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00521">521</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="aaa5301afb7afa81ba494aee94f540558" name="aaa5301afb7afa81ba494aee94f540558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5301afb7afa81ba494aee94f540558">&#9670;&#160;</a></span>GetMemoryType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::GetMemoryType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a MemoryType that is currently valid. If both the host and the device pointers are currently valid, then the device memory type is returned. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01234">1234</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a65c2de394522406a1a0712343b1eb1f8" name="a65c2de394522406a1a0712343b1eb1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c2de394522406a1a0712343b1eb1f8">&#9670;&#160;</a></span>HostIsValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::HostIsValid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if host pointer is valid. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01248">1248</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a54c80c40247a6a501cbc892063c19410" name="a54c80c40247a6a501cbc892063c19410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c80c40247a6a501cbc892063c19410">&#9670;&#160;</a></span>MakeAlias()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::MakeAlias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a memory object that points inside the memory object <em>base</em>. </p>
<p>The new <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object uses the same <a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6" title="Memory types supported by MFEM.">MemoryType(s)</a> as <em>base</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The current memory is NOT deleted by this method. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01035">1035</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="af8653bd0ddede4b32b498d56eab7a72f" name="af8653bd0ddede4b32b498d56eab7a72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8653bd0ddede4b32b498d56eab7a72f">&#9670;&#160;</a></span>New() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::New </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate host memory for <em>size</em> entries with the current host memory type returned by <a class="el" href="classmfem_1_1MemoryManager.html#a8242b5d31866354a39a9499aaceb1e10">MemoryManager::GetHostMemoryType()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The current memory is NOT deleted by this method. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00938">938</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a3ae5b9bf408ab503de58fc6951148710" name="a3ae5b9bf408ab503de58fc6951148710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae5b9bf408ab503de58fc6951148710">&#9670;&#160;</a></span>New() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::New </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>h_mt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>d_mt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for <em>size</em> entries with the given host MemoryType <em>h_mt</em> and device MemoryType <em>d_mt</em>. </p>
<p>The newly allocated memory is not initialized. The host pointer is set as valid.</p>
<dl class="section note"><dt>Note</dt><dd>The current memory is NOT deleted by this method. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00960">960</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a08bbd339334b49ff73abee09cf3f60ec" name="a08bbd339334b49ff73abee09cf3f60ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08bbd339334b49ff73abee09cf3f60ec">&#9670;&#160;</a></span>New() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::New </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>mt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for <em>size</em> entries with the given MemoryType. </p>
<p>The newly allocated memory is not initialized, however the given MemoryType is still set as valid.</p>
<p>When <em>mt</em> is a host type, the device MemoryType will be set later, if requested, using the dual type of <em>mt</em>, see <a class="el" href="classmfem_1_1MemoryManager.html#ad5ab299c4a408611faa119600a34a357" title="Return the dual MemoryType of the given one, mt.">MemoryManager::GetDualMemoryType()</a>.</p>
<p>When <em>mt</em> is a device type, the host MemoryType will be set immediately to be the dual of <em>mt</em>, see <a class="el" href="classmfem_1_1MemoryManager.html#ad5ab299c4a408611faa119600a34a357" title="Return the dual MemoryType of the given one, mt.">MemoryManager::GetDualMemoryType()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The current memory is NOT deleted by this method. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00948">948</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a9b045973f3f7cebf6b0db63f17f0581e" name="a9b045973f3f7cebf6b0db63f17f0581e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b045973f3f7cebf6b0db63f17f0581e">&#9670;&#160;</a></span>operator const T *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator const T *</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the host memory as const T* (implicit conversion). </p>
<p>This method can be used only if the host pointer is currently valid (the device pointer may be valid or invalid).</p>
<p>When the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> is empty, this method can be used and it returns NULL. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01146">1146</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a9dc509c7f05bd961e11fe98cebd3d701" name="a9dc509c7f05bd961e11fe98cebd3d701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc509c7f05bd961e11fe98cebd3d701">&#9670;&#160;</a></span>operator const U *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator const U *</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the host memory via explicit typecast, const version. </p>
<p>A pointer to type T must be reinterpret_cast-able to a pointer to type const U.</p>
<p>This method can be used only if the host pointer is currently valid (the device pointer may be valid or invalid).</p>
<p>When the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> is empty, this method can be used and it returns NULL. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01163">1163</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="abe61dd5aa674a0726a086a6936ca5f99" name="abe61dd5aa674a0726a086a6936ca5f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe61dd5aa674a0726a086a6936ca5f99">&#9670;&#160;</a></span>operator T*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator T*</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the host memory as T* (implicit conversion). </p>
<p>When the type T is const-qualified, this method can be used only if the host pointer is currently valid (the device pointer may be valid or invalid).</p>
<p>When the type T is not const-qualified, this method can be used only if the host pointer is the only valid pointer.</p>
<p>When the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> is empty, this method can be used and it returns NULL. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01136">1136</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="acbfcca16e743e987a978f50796af216b" name="acbfcca16e743e987a978f50796af216b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfcca16e743e987a978f50796af216b">&#9670;&#160;</a></span>operator U*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator U*</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the host memory via explicit typecast. </p>
<p>A pointer to type T must be reinterpret_cast-able to a pointer to type U. In particular, this method cannot be used to cast away const-ness from the base type T.</p>
<p>When the type U is const-qualified, this method can be used only if the host pointer is currently valid (the device pointer may be valid or invalid).</p>
<p>When the type U is not const-qualified, this method can be used only if the host pointer is the only valid pointer.</p>
<p>When the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> is empty, this method can be used and it returns NULL. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01153">1153</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a4b30d979258a63a39ac1d02bbe8afd24" name="a4b30d979258a63a39ac1d02bbe8afd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b30d979258a63a39ac1d02bbe8afd24">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp; <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assignment operator: default. </p>

</div>
</div>
<a id="af92050195c2e5faf16b95b464ac2582f" name="af92050195c2e5faf16b95b464ac2582f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92050195c2e5faf16b95b464ac2582f">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmfem_1_1Memory.html">Memory</a> &amp; <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator. Sets the pointers and associated ownership of validity flags of <em>*this</em> to those of <em>other</em>. Resets <em>other</em>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00227">227</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a2fe83db8e05919fc63ddba24b823bf7b" name="a2fe83db8e05919fc63ddba24b823bf7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe83db8e05919fc63ddba24b823bf7b">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmfem_1_1Array.html">Array</a> subscript operator for host memory. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01121">1121</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="aece12a0a2d5c784f3a510d65e580d5d0" name="aece12a0a2d5c784f3a510d65e580d5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece12a0a2d5c784f3a510d65e580d5d0">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmfem_1_1Array.html">Array</a> subscript operator for host memory, const version. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01129">1129</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a0a62868f97f98e658ba2b924faa7a782" name="a0a62868f97f98e658ba2b924faa7a782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a62868f97f98e658ba2b924faa7a782">&#9670;&#160;</a></span>OwnsDevicePtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::OwnsDevicePtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the device pointer is owned. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00291">291</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="aa6332d8de617e32e46a04f0af78bc7a8" name="aa6332d8de617e32e46a04f0af78bc7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6332d8de617e32e46a04f0af78bc7a8">&#9670;&#160;</a></span>OwnsHostPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::OwnsHostPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the host pointer is owned. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00282">282</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="ac3d205fae2e89586bd2b805c624cb936" name="ac3d205fae2e89586bd2b805c624cb936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d205fae2e89586bd2b805c624cb936">&#9670;&#160;</a></span>PrintFlags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::PrintFlags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the internal flags. </p>
<p>This method can be useful for debugging. It is explicitly instantiated for Memory&lt;T&gt; with T = int and T = real_t. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01334">1334</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="aca11c25b3bab365636420fe0f95c740f" name="aca11c25b3bab365636420fe0f95c740f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca11c25b3bab365636420fe0f95c740f">&#9670;&#160;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9ad">MemoryClass</a>&#160;</td>
          <td class="paramname"><em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get read-only access to the memory with the given MemoryClass. </p>
<p>The parameter <em>size</em> must not exceed the <a class="el" href="classmfem_1_1Memory.html#a2c60a5002e4a1972651b17f8e7231c99" title="Return the size of the allocated memory.">Capacity()</a>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01183">1183</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a41c5196970fcdb804fda39b12ce33a89" name="a41c5196970fcdb804fda39b12ce33a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c5196970fcdb804fda39b12ce33a89">&#9670;&#160;</a></span>ReadWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::ReadWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9ad">MemoryClass</a>&#160;</td>
          <td class="paramname"><em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get read-write access to the memory with the given MemoryClass. </p>
<p>If only read or only write access is needed, then the methods <a class="el" href="classmfem_1_1Memory.html#aca11c25b3bab365636420fe0f95c740f" title="Get read-only access to the memory with the given MemoryClass.">Read()</a> or <a class="el" href="classmfem_1_1Memory.html#a0e426fd5bdf03fced16e7fc748e618b3" title="Get write-only access to the memory with the given MemoryClass.">Write()</a> should be used instead of this method.</p>
<p>The parameter <em>size</em> must not exceed the <a class="el" href="classmfem_1_1Memory.html#a2c60a5002e4a1972651b17f8e7231c99" title="Return the size of the allocated memory.">Capacity()</a>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01170">1170</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="ae0cb658936a2f7ef0033e7144b8f2ded" name="ae0cb658936a2f7ef0033e7144b8f2ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cb658936a2f7ef0033e7144b8f2ded">&#9670;&#160;</a></span>Reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Reset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the memory to be empty, ensuring that <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a> will be a no-op. </p>
<p>This is the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> class equivalent to setting a pointer to NULL, see <a class="el" href="classmfem_1_1Memory.html#aab88a8b55cb9d59a452b3e3e49e1a03a" title="Return true if the Memory object is empty, see Reset().">Empty()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The current memory is NOT deleted by this method. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00920">920</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a52ac2ae58da2383aa01e8f812292fe0a" name="a52ac2ae58da2383aa01e8f812292fe0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ac2ae58da2383aa01e8f812292fe0a">&#9670;&#160;</a></span>Reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>host_mt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the memory and set the host memory type. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00929">929</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a207ff2d7f471881a398f85866d506951" name="a207ff2d7f471881a398f85866d506951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207ff2d7f471881a398f85866d506951">&#9670;&#160;</a></span>SetDeviceMemoryType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::SetDeviceMemoryType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>d_mt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the device MemoryType to be used by the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object. </p>
<p>If the specified <em>d_mt</em> is not a device MemoryType, i.e. not one of the types in <a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9adae10b6ab6a278644ce40631f62f360b6d">MemoryClass::DEVICE</a>, then this method will return immediately.</p>
<p>If the device MemoryType has been previously set to a different type and the actual device memory has been allocated, this method will trigger an error. This method will not perform the actual device memory allocation, however, the allocation may already exist if the MemoryType is the same as the current one.</p>
<p>If the <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> is an alias <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a>, the device MemoryType of its base will be updated as described above. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01080">1080</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a2362473c1d01b4dc65a89c0b2b014624" name="a2362473c1d01b4dc65a89c0b2b014624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2362473c1d01b4dc65a89c0b2b014624">&#9670;&#160;</a></span>SetDevicePtrOwner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::SetDevicePtrOwner </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set/clear the ownership flag for the device pointer. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00295">295</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a056cd85d58fc6ba570710765a69651eb" name="a056cd85d58fc6ba570710765a69651eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056cd85d58fc6ba570710765a69651eb">&#9670;&#160;</a></span>SetHostPtrOwner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::SetHostPtrOwner </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set/clear the ownership flag for the host pointer. Ownership indicates whether the pointer will be deleted by the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00286">286</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="abb9792e65462ac4c305ffd32cc0f2123" name="abb9792e65462ac4c305ffd32cc0f2123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9792e65462ac4c305ffd32cc0f2123">&#9670;&#160;</a></span>Sync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Sync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the host/device pointer validity flags from <em>other</em> to <em>*this</em>. </p>
<p>This method synchronizes the pointer validity flags of two <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> objects that use the same host/device pointers, or when <em>*this</em> is an alias (sub-Memory) of <em>other</em>. Typically, this method should be called after <em>other</em> is manipulated in a way that changes its pointer validity flags (e.g. it was moved from device to host memory). </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01209">1209</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a973ee95b759c050ed6523a8e8257248e" name="a973ee95b759c050ed6523a8e8257248e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973ee95b759c050ed6523a8e8257248e">&#9670;&#160;</a></span>SyncAlias()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::SyncAlias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmfem_1_1Memory.html">Memory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alias_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the alias <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> <em>*this</em> to match the memory location (all valid locations) of its base <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a>, <em>base</em>. </p>
<p>This method is useful when alias <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> is moved and manipulated in a different memory space. Such operations render the pointer validity flags of the base incorrect. Calling this method will ensure that <em>base</em> is up-to-date. Note that this is achieved by moving/copying <em>*this</em> (if necessary), and not <em>base</em>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01223">1223</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a91d437d69150d64b5f15bf9f416ad3d1" name="a91d437d69150d64b5f15bf9f416ad3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d437d69150d64b5f15bf9f416ad3d1">&#9670;&#160;</a></span>UseDevice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::UseDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the internal device flag. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00304">304</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="aca68c445b1ceef940243d2a156b872a0" name="aca68c445b1ceef940243d2a156b872a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca68c445b1ceef940243d2a156b872a0">&#9670;&#160;</a></span>UseDevice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::UseDevice </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_dev</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the internal device flag. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00307">307</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="af12c48b125333ecdcc72edd749d95a5f" name="af12c48b125333ecdcc72edd749d95a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12c48b125333ecdcc72edd749d95a5f">&#9670;&#160;</a></span>Wrap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Wrap </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>h_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>h_mt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>valid_host</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>valid_device</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wrap an externally pair of allocated pointers, <em>h_ptr</em> and <em>d_ptr</em>, of the given host MemoryType <em>h_mt</em>. The new memory object will have the device MemoryType set as valid unless specified otherwise by the parameters <em>valid_host</em> and <em>valid_device</em>.</p>
<p>The given <em>h_ptr</em> and <em>d_ptr</em> must be allocated appropriately for the given host MemoryType and its dual device MemoryType as defined by <a class="el" href="classmfem_1_1MemoryManager.html#ad5ab299c4a408611faa119600a34a357" title="Return the dual MemoryType of the given one, mt.">MemoryManager::GetDualMemoryType()</a>.</p>
<p>The parameter <em>own</em> determines whether both <em>h_ptr</em> and <em>d_ptr</em> will be deleted when the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a> is called.</p>
<p>The parameters <em>valid_host</em> and <em>valid_device</em> determine which pointers, host and/or device, will be marked as valid; at least one of the two parameters must be set to true.</p>
<dl class="section note"><dt>Note</dt><dd>Ownership can also be controlled by using the following methods:<ul>
<li>ClearOwnerFlags,</li>
<li>SetHostPtrOwner,</li>
<li>SetDevicePtrOwner.</li>
</ul>
</dd>
<dd>
The current memory is NOT deleted by this method. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01018">1018</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="ae33f0d9783e1129d8cf9d792b1aa360f" name="ae33f0d9783e1129d8cf9d792b1aa360f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33f0d9783e1129d8cf9d792b1aa360f">&#9670;&#160;</a></span>Wrap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Wrap </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap an externally allocated host pointer, <em>ptr</em> with the current host memory type returned by <a class="el" href="classmfem_1_1MemoryManager.html#a8242b5d31866354a39a9499aaceb1e10">MemoryManager::GetHostMemoryType()</a>. </p>
<p>The parameter <em>own</em> determines whether <em>ptr</em> will be deleted when the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a> is called.</p>
<dl class="section note"><dt>Note</dt><dd>The current memory is NOT deleted by this method. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00971">971</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a109d0d1215affe85a413f182f7c1e829" name="a109d0d1215affe85a413f182f7c1e829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109d0d1215affe85a413f182f7c1e829">&#9670;&#160;</a></span>Wrap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Wrap </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a>&#160;</td>
          <td class="paramname"><em>mt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>own</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap an externally allocated pointer, <em>ptr</em>, of the given MemoryType. </p>
<p>The new memory object will have the given MemoryType set as valid.</p>
<p>The given <em>ptr</em> must be allocated appropriately for the given MemoryType.</p>
<p>The parameter <em>own</em> determines whether <em>ptr</em> will be deleted when the method <a class="el" href="classmfem_1_1Memory.html#ae561fa2849413502ad438425d430ab3e" title="Delete the owned pointers and reset the Memory object.">Delete()</a> is called.</p>
<dl class="section note"><dt>Note</dt><dd>The current memory is NOT deleted by this method. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00993">993</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a0e426fd5bdf03fced16e7fc748e618b3" name="a0e426fd5bdf03fced16e7fc748e618b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e426fd5bdf03fced16e7fc748e618b3">&#9670;&#160;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9ad">MemoryClass</a>&#160;</td>
          <td class="paramname"><em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get write-only access to the memory with the given MemoryClass. </p>
<p>The parameter <em>size</em> must not exceed the <a class="el" href="classmfem_1_1Memory.html#a2c60a5002e4a1972651b17f8e7231c99" title="Return the size of the allocated memory.">Capacity()</a>.</p>
<p>The contents of the returned pointer is undefined, unless it was validated by a previous call to <a class="el" href="classmfem_1_1Memory.html#aca11c25b3bab365636420fe0f95c740f" title="Get read-only access to the memory with the given MemoryClass.">Read()</a> or <a class="el" href="classmfem_1_1Memory.html#a41c5196970fcdb804fda39b12ce33a89" title="Get read-write access to the memory with the given MemoryClass.">ReadWrite()</a> with the same MemoryClass. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l01196">1196</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a714d9445184f29c663c1c02da59e9727" name="a714d9445184f29c663c1c02da59e9727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714d9445184f29c663c1c02da59e9727">&#9670;&#160;</a></span>MemoryManager</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classmfem_1_1MemoryManager.html">MemoryManager</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00170">170</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="aa80ea4d950a39cb98da7a6da3cf862bc" name="aa80ea4d950a39cb98da7a6da3cf862bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80ea4d950a39cb98da7a6da3cf862bc">&#9670;&#160;</a></span>MemoryPrintFlags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryPrintFlags </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the state of a <a class="el" href="classmfem_1_1Memory.html" title="Class used by MFEM to store pointers to host and/or device memory.">Memory</a> object based on its internal flags. Useful in a debugger. See also <a class="el" href="classmfem_1_1Memory.html#ac3d205fae2e89586bd2b805c624cb936" title="Print the internal flags.">Memory&lt;T&gt;::PrintFlags()</a>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8cpp_source.html#l01688">1688</a> of file <a class="el" href="mem__manager_8cpp_source.html">mem_manager.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af3d2f083d939a842e7a822882c69615c" name="af3d2f083d939a842e7a822882c69615c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d2f083d939a842e7a822882c69615c">&#9670;&#160;</a></span>capacity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of the allocated memory. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00200">200</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="ac929fdb65bbfc48a96dc53479c680a6f" name="ac929fdb65bbfc48a96dc53479c680a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac929fdb65bbfc48a96dc53479c680a6f">&#9670;&#160;</a></span>flags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit flags defined from the <a class="el" href="classmfem_1_1Memory.html#a3d0f39428ffcae585ee8a5e07d6293c8">FlagMask</a> enum. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00202">202</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="a465ea2a53d95684f97d8554dc80d8c95" name="a465ea2a53d95684f97d8554dc80d8c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465ea2a53d95684f97d8554dc80d8c95">&#9670;&#160;</a></span>h_mt</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemfem.html#adb01975babc73b14adfe02bf6a7c77f6">MemoryType</a> <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::h_mt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Host memory type. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00201">201</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<a id="ab74d8712d2e64510cf8bfd256b656c16" name="ab74d8712d2e64510cf8bfd256b656c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74d8712d2e64510cf8bfd256b656c16">&#9670;&#160;</a></span>h_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classmfem_1_1Memory.html">mfem::Memory</a>&lt; T &gt;::h_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to host memory. Not owned. </p>
<p>The type of the pointer is given by the field <a class="el" href="classmfem_1_1Memory.html#a465ea2a53d95684f97d8554dc80d8c95" title="Host memory type.">h_mt</a>; it can be any type from <a class="el" href="namespacemfem.html#a4c3f8b89617067ca6e03323849eec9adab9361011891280a44d85b967739cc6a5">MemoryClass::HOST</a>. </p>

<p class="definition">Definition at line <a class="el" href="mem__manager_8hpp_source.html#l00199">199</a> of file <a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>general/<a class="el" href="mem__manager_8hpp_source.html">mem_manager.hpp</a></li>
<li>general/<a class="el" href="mem__manager_8cpp_source.html">mem_manager.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
